@startuml ERD

!define TABLE(name) entity name << (T,#FFAAAA) >>
!define PK(x) <b><color:#b8860b>x</color></b>
!define FK(x) <color:#aaaaaa>x</color>
!define UNIQUE(x) <u>x</u>

skinparam linetype ortho
skinparam entity {
    BackgroundColor #f5f5f5
    BorderColor #333333
}

TABLE(resume_raw) {
    PK(id) : UUID
    --
    source_text : TEXT
    UNIQUE(content_hash) : VARCHAR(64)
    created_at : TIMESTAMP
}

TABLE(vacancy_raw) {
    PK(id) : UUID
    --
    source_text : TEXT
    UNIQUE(content_hash) : VARCHAR(64)
    created_at : TIMESTAMP
}

TABLE(ai_result) {
    PK(id) : UUID
    --
    operation : VARCHAR(50)
    input_hash : VARCHAR(64)
    output_json : JSONB
    model : VARCHAR(100)
    provider : VARCHAR(50)
    error : TEXT
    created_at : TIMESTAMP
    --
    <<UNIQUE>> (operation, input_hash)
}

TABLE(analysis_link) {
    PK(id) : UUID
    --
    FK(resume_id) : UUID
    FK(vacancy_id) : UUID
    FK(analysis_result_id) : UUID
    created_at : TIMESTAMP
}

resume_raw ||--o{ analysis_link : "resume_id"
vacancy_raw ||--o{ analysis_link : "vacancy_id"
ai_result ||--o{ analysis_link : "analysis_result_id"

note right of ai_result
  **operation** values:
  - parse_resume
  - parse_vacancy
  - analyze_match
  
  **output_json** contains
  structured LLM response
end note

note bottom of analysis_link
  Links resume + vacancy
  to their match analysis
  
  ON DELETE CASCADE
  for all FKs
end note

@enduml
